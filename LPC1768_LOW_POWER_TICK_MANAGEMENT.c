/*
 * FreeRTOS Kernel V10.3.1
 * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/* Standard includes. */
#include <limits.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "LPC1768_LOW_POWER_TICK_MANAGEMENT.h"
#include "math.h"
#include "ClockControl.h"

/* User defined Variables */
#include <stdbool.h>

// const uint8_t mValues[12] = {36, 33, 30, 27, 24, 18, 12, 9, 6, 3};
// const int frequencyLevels[] = {96, 88, 80, 72, 64, 48, 32, 24, 16, 8};
// const int staticTickIncrement[] = {0, 0, 0, 0, 0, 1, 2, 3, 5, 11};
// const int periodicTickIncrement[] = {0, 11, 5, 3, 2, 0, 0, 0, 0, 0};
// volatile int currentFrequencyLevel = 0;
// volatile short periodicTickIncrementCount = 0;
// volatile bool frequencyChanged = false;
// const short availableFrequencyLevels = 10;

volatile int currentFrequencyLevel = 0;
volatile short periodicTickIncrementCount = 0;
volatile bool frequencyChanged = false;

extern int *deadlines[];
extern int mainTaskPeriods[];
extern int mainWorstCaseComputeTime[];

#define SBIT_TIMER1 2
#define SBIT_MR0I 0
#define SBIT_MR0R 1
#define SBIT_CNTEN 0
#define SBIT_CNRST 1
#define PCLK_TIMER1 4

/* The frequency at which TIM2 will run. */
#define lpCLOCK_INPUT_FREQUENCY (10000UL)

/* Calculate how many clock increments make up a single tick period. */
static const uint32_t ulReloadValueForOneTick = ((lpCLOCK_INPUT_FREQUENCY / configTICK_RATE_HZ) - 1);
unsigned int getPrescalarFor100Us(uint8_t timerPclkBit);

/* Flag set from the tick interrupt to allow the sleep processing to know if
sleep mode was exited because of an tick interrupt or a different interrupt. */
static volatile uint32_t ulTickFlag = pdFALSE;

/* Holds the maximum number of ticks that can be suppressed - which is
basically how far into the future an interrupt can be generated. Set during
initialisation. */
static TickType_t xMaximumPossibleSuppressedTicks = 0;

// /* For debugging*/
#ifndef FILE_H
#define FILE_H
#endif
#include "PowerControl.h"
#include "ClockControl.h"

#define LED1 18 //
#define LED2 20 //
#define LED3 21 //
#define LED4 23 //

/* Write to GPIO 2 on Port 18,20,21,23
 Initialized on main  otherwise initialize here
 Can't use mbed.h cause its not a .cpp file, and a .cpp file complains about the normal port tick 
 interrupt
LED1 = P1_18,
LED2 = P1_20,
LED3 = P1_21,
LED4 = P1_23,
*/

#ifdef DEBUG

#define configPRE_SLEEP_PROCESSING(x) \
	LPC_GPIO1->FIOPIN = (1 << LED1);  \
	Sleep();
#define configPOST_SLEEP_PROCESSING(x) LPC_GPIO1->FIOPIN = (0 << LED1);

#else
#define configPRE_SLEEP_PROCESSING(x) Sleep();

#endif

void frequencyLevelSelector(int level)
{
	if (level < 0 || level > availableFrequencyLevels)
	{
		return;
	}

	currentFrequencyLevel = level;
	setSystemFrequency(3, 0, mValues[level], 1);
	frequencyChanged = true;
}

/*
 * When configDYNAMIC_FREQUENCY_LOW_POWER_MODE is set to 1 then the tick interrupt
 * is generated by the TIM2 peripheral.  The TIM2 configuration and handling
 * functions are defined in this file.  Note the RTC is not used as there does
 * not appear to be a way to read back the RTC count value, and therefore the
 * only way of knowing exactly how long a sleep lasted is to use the very low
 * resolution calendar time.
 *
 * When configDYNAMIC_FREQUENCY_LOW_POWER_MODE is set to 0 the tick interrupt is
 * generated by the standard FreeRTOS Cortex-M port layer, which uses the
 * SysTick timer.
 */

#if configDYNAMIC_FREQUENCY_LOW_POWER_MODE == 1

void dynamicFrequencySysTickHandler(void)
{
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();

	/* Increment the RTOS tick. */

	if (xTaskIncrementTick() != pdFALSE)
	{
		/* A context switch is required.  Context switching is performed in
		the PendSV interrupt.  Pend the PendSV interrupt. */
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
	}

	if (frequencyChanged)
	{
		periodicTickIncrementCount = 0;
		updatePrescalerTIMER1();
		frequencyChanged = false;
	}

	// short extraTicks = staticTickIncrement[currentFrequencyLevel];
	// if (periodicTickIncrementCount == periodicTickIncrement[currentFrequencyLevel] && periodicTickIncrement[currentFrequencyLevel] != 0)
	// {
	// 	extraTicks++;
	// 	periodicTickIncrementCount = 0;
	// }

	// for (int i = 0; i < extraTicks; i++)
	// {
	// 	/* Increment the RTOS tick. */
	// 	if (xTaskIncrementTick() != pdFALSE)
	// 	{
	// 		/* A context switch is required.  Context switching is performed in
	// 		the PendSV interrupt.  Pend the PendSV interrupt. */
	// 		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
	// 	}
	// }

	periodicTickIncrementCount++;

	portENABLE_INTERRUPTS();

	/* The CPU woke because of a tick. */
	ulTickFlag = pdTRUE;
}

void vPortSetupTimerInterrupt(void)
{

	LPC_SC->PCONP |= (1 << SBIT_TIMER1); /* Power ON Timer1 */

	LPC_TIM1->MCR = (1 << SBIT_MR0I) | (1 << SBIT_MR0R); /* Clear TC on MR0 match and Generate Interrupt*/
	LPC_TIM1->PR = getPrescalarFor100Us(PCLK_TIMER1);	 /* Prescalar for 1us */
	LPC_TIM1->MR0 = (1000 / configTICK_RATE_HZ) * 10;	 /* Load timer value to generate Tick Rate delay*/
	LPC_TIM1->TCR = (1 << SBIT_CNTEN);					 /* Start timer by setting the Counter Enable*/
	NVIC_EnableIRQ(TIMER1_IRQn);

	/* See the comments where xMaximumPossibleSuppressedTicks is declared. */
	xMaximumPossibleSuppressedTicks = ((unsigned long)USHRT_MAX) / ulReloadValueForOneTick;
}

void disableTIMER1(void)
{

	LPC_TIM1->TCR = (0 << SBIT_CNTEN); /* Start timer by setting the Counter Enable*/
	NVIC_DisableIRQ(TIMER1_IRQn);	   /* Enable Timer1 Interrupt */
}

void enableTIMER1(void)
{

	LPC_TIM1->TCR = (1 << SBIT_CNTEN); /* Stop timer by setting the Counter Enable to 0*/
	NVIC_EnableIRQ(TIMER1_IRQn);	   /* Disable Timer1 Interrupt */
}

void resetTIMER1(void)
{

	LPC_TIM1->TCR = (1 << SBIT_CNRST); /* Reset the timer by setting the Counter Reset*/
	LPC_TIM1->TCR = (0 << SBIT_CNRST); /* Reset the timer by setting the Counter Reset*/
}

void setReloadValueTIMER1(int reloadValue)
{
	LPC_TIM1->MR0 = reloadValue;
}

void setCounterTIMER1(uint32_t counterValue)
{
	LPC_TIM1->TC = counterValue;
}

uint32_t getCounterTIMER1(void)
{
	return LPC_TIM1->TC;
}

void updatePrescalerTIMER1(void)
{
	LPC_TIM1->PR = getPrescalarFor100Us(PCLK_TIMER1);
}
void TIMER1_IRQHandler(void)
{
	LPC_TIM1->IR |= (1 << 0); //Clear MR0 Interrupt flag
	dynamicFrequencySysTickHandler();
}

/* Courtesy of https://www.exploreembedded.com/wiki/LPC1768:_Timers */
unsigned int getPrescalarFor100Us(uint8_t timerPclkBit)
{
	unsigned int pclk, prescalarFor100Us;
	pclk = (LPC_SC->PCLKSEL0 >> timerPclkBit) & 0x03; /* get the pclk info for required timer */

	switch (pclk) /* Decode the bits to determine the pclk*/
	{
	case 0x00:
		pclk = SystemCoreClock / 4;
		break;

	case 0x01:
		pclk = SystemCoreClock;
		break;

	case 0x02:
		pclk = SystemCoreClock / 2;
		break;

	case 0x03:
		pclk = SystemCoreClock / 8;
		break;
	}

	prescalarFor100Us = pclk / 10000 - 1; /* Prescalar for 1us (1000000Counts/sec) */
	//prescalarForMs = pclk / 1000 - 1; /* Prescalar for 1us (1000000Counts/sec) */
	//prescalarForUs = pclk / 1000000 - 1; /* Prescalar for 1us (1000000Counts/sec) */

	return prescalarFor100Us;
}

void vApplicationSleep(TickType_t xExpectedIdleTime)
{
	uint32_t ulCounterValue, ulReloadValue, ulCompleteTickPeriods, ulCompletedSysTickDecrements;
	TickType_t xModifiableIdleTime;

	/* Make sure the SysTick reload value does not overflow the counter. */
	if (xExpectedIdleTime > xMaximumPossibleSuppressedTicks)
	{
		xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
	}

	/* Stop the Tick Timer momentarily.  The time the Tick Timer is stopped for
	is accounted for as best it can be, but using the tickless mode will
	inevitably result in some tiny drift of the time maintained by the
	kernel with respect to calendar time. */
	disableTIMER1();

	/* Calculate the reload value required to wait xExpectedIdleTime
	tick periods.  -1 is used because this code will execute part way
	through one of the tick periods. */
	ulReloadValue = ulReloadValueForOneTick * xExpectedIdleTime;

	// if (ulReloadValue > ulStoppedTimerCompensation)
	// {
	// 	ulReloadValue -= ulStoppedTimerCompensation;
	// }

	/* Enter a critical section but don't use the taskENTER_CRITICAL()
	method as that will mask interrupts that should exit sleep mode. */
	__asm volatile("cpsid i" ::
					   : "memory");
	__asm volatile("dsb");
	__asm volatile("isb");

	/* The tick flag is set to false before sleeping.  If it is true when sleep
	mode is exited then sleep mode was probably exited because the tick was
	suppressed for the entire xExpectedIdleTime period. */
	ulTickFlag = pdFALSE;

	/* If a context switch is pending or a task is waiting for the scheduler
	to be unsuspended then abandon the low power entry. */
	if (eTaskConfirmSleepModeStatus() == eAbortSleep)
	{
		/* Restart from whatever is left in the count register to complete
		this tick period. */
		enableTIMER1();

		/* Re-enable interrupts - see comments above the cpsid instruction()
		above. */
		__asm volatile("cpsie i" ::
						   : "memory");
	}
	else
	{
		/* Adjust the TIM2 value to take into account that the current time
		slice is already partially complete. */
		ulReloadValue -= (uint32_t)getCounterTIMER1();
		/* Set the new reload value. */

		//portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
		setReloadValueTIMER1(ulReloadValue);

		/* Clear the SysTick count flag and set the count value back to
		zero. */
		resetTIMER1();
		setCounterTIMER1(0);

		/* Restart SysTick. */
		enableTIMER1();

		/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
		set its parameter to 0 to indicate that its implementation contains
		its own wait for interrupt or wait for event instruction, and so wfi
		should not be executed again.  However, the original expected idle
		time variable must remain unmodified, so a copy is taken. */
		xModifiableIdleTime = xExpectedIdleTime;
		configPRE_SLEEP_PROCESSING(xModifiableIdleTime);
		if (xModifiableIdleTime > 0)
		{
			__asm volatile("dsb" ::
							   : "memory");
			__asm volatile("wfi");
			__asm volatile("isb");
		}
		configPOST_SLEEP_PROCESSING(xExpectedIdleTime);

		/* Re-enable interrupts to allow the interrupt that brought the MCU
		out of sleep mode to execute immediately.  see comments above
		__disable_interrupt() call above. */
		__asm volatile("cpsie i" ::
						   : "memory");
		__asm volatile("dsb");
		__asm volatile("isb");

		/* Disable interrupts again because the clock is about to be stopped
		and interrupts that execute while the clock is stopped will increase
		any slippage between the time maintained by the RTOS and calendar
		time. */
		__asm volatile("cpsid i" ::
						   : "memory");
		__asm volatile("dsb");
		__asm volatile("isb");

		/* Disable the SysTick clock without reading the
		portNVIC_SYSTICK_CTRL_REG register to ensure the
		portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
		the time the SysTick is stopped for is accounted for as best it can
		be, but using the tickless mode will inevitably result in some tiny
		drift of the time maintained by the kernel with respect to calendar
		time*/
		disableTIMER1();

		/* Determine if the SysTick clock has already counted to zero and
		been set back to the current reload value (the reload back being
		correct for the entire expected idle time) or if the SysTick is yet
		to count to zero (in which case an interrupt other than the SysTick
		must have brought the system out of sleep mode). */
		if (ulTickFlag != pdFALSE)
		{
			/* The tick interrupt is already pending, and the SysTick count
			reloaded with ulReloadValue.  Reset the
			portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
			period. */
			ulCounterValue = ulReloadValueForOneTick - getCounterTIMER1();

			/* Trap under/overflows before the calculated value is used. */
			configASSERT(ulCounterValue >= 0);

			setReloadValueTIMER1(ulCounterValue);
			setCounterTIMER1(0);

			/* As the pending tick will be processed as soon as this
			function exits, the tick value maintained by the tick is stepped
			forward by one less than the time spent waiting. */
			ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
		}
		else
		{
			/* Something other than the tick interrupt ended the sleep.
			Work out how long the sleep lasted rounded to complete tick
			periods (not the ulReload value which accounted for part
			ticks). */
			ulCompleteTickPeriods = (getCounterTIMER1()) / ulReloadValueForOneTick;

			/* The reload value is set to whatever fraction of a single tick
			period remains. */
			ulCounterValue = (getCounterTIMER1()) - (ulCompleteTickPeriods * ulReloadValueForOneTick);

			if (ulCounterValue == 0)
			{
				/* There is no fraction remaining. */
				ulCounterValue = ulReloadValueForOneTick;
				ulCompleteTickPeriods++;
			}

			setReloadValueTIMER1(ulCounterValue);
			setCounterTIMER1(0);
		}

		/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
		again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
		value. */
		setCounterTIMER1(0);
		enableTIMER1();
		vTaskStepTick(ulCompleteTickPeriods);
		setReloadValueTIMER1(ulReloadValueForOneTick);

		/* Exit with interrupts enabled. */
		__asm volatile("cpsie i" ::
						   : "memory");
	}
}

#endif

int convertTickToCycles(int ticks)
{
	return ticks * (frequencyLevels[currentFrequencyLevel] / configTICK_RATE_HZ);
}
/* Static voltage Scak=ling Implementation
** 
** Mode 0: RM
	Mode 1 EDF*/

#ifdef __cplusplus
extern "C"
#endif
	int
	staticVoltageScalingFrequencyLevelSelector(int numberOfTasks,
											   int *taskPeriods, int *taskWorstCaseComputeTime, int mode)
{

	float alphaToTest = 0.0f;
	bool validAlpha = true;
	int i = 0;
	int selectedFrequencyLevel = 0;

	/* Even if it fails in the max frequency, will return 0 and operate at max frequency
		If it is valid through all levels the second condition will act and stop the loop*/
	if (mode == 0) //RM
	{
		while (validAlpha && i < availableFrequencyLevels)
		{
			alphaToTest = (frequencyLevels[i] * 1.0f) / (frequencyLevels[0] * 1.0f);
			validAlpha = staticVoltageScalingRM_Test(numberOfTasks, taskPeriods, taskWorstCaseComputeTime, alphaToTest);
			if (validAlpha)
				i++;
		}
		selectedFrequencyLevel = i - 1;
		frequencyLevelSelector(selectedFrequencyLevel);
		return selectedFrequencyLevel;
	}

	if (mode == 1) //EDF
	{
		while (validAlpha && i < availableFrequencyLevels)
		{
			alphaToTest = (frequencyLevels[i] * 1.0f) / (frequencyLevels[0] * 1.0f);
			validAlpha = staticVoltageScalingEDF_Test(numberOfTasks, taskPeriods, taskWorstCaseComputeTime, alphaToTest);
			if (validAlpha)
				i++;
		}
		selectedFrequencyLevel = i - 1;
		frequencyLevelSelector(selectedFrequencyLevel);
		return selectedFrequencyLevel;
	}
	return 0;
}

bool staticVoltageScalingRM_Test(int numberOfTasks,
								 int *taskPeriods, int *taskWorstCaseComputeTime, float alpha)
{

	int currentTaskInTest = 0;
	float computeTimeSum = 0;

	while (1)
	{
		for (int i = 0; i < currentTaskInTest + 1; i++)
		{
			computeTimeSum += ceil((taskPeriods[currentTaskInTest] / 1.0f) / (taskPeriods[i] / 1.0f)) * taskWorstCaseComputeTime[i];
		}

		if (alpha * taskPeriods[currentTaskInTest] >= computeTimeSum)
		{

			if (currentTaskInTest + 1 == numberOfTasks)
				return true; //Alpha is valid and deadlines are not violated

			/* Reset the sum and test the next Task*/
			computeTimeSum = 0;
			currentTaskInTest++;
		}
		else
			return false;
	}
}

bool staticVoltageScalingEDF_Test(int numberOfTasks,
								  int *taskPeriods, int *taskWorstCaseComputeTime, float alpha)
{

	float computeTimeSum = 0;

	for (int i = 0; i < numberOfTasks; i++)
	{
		computeTimeSum += (taskWorstCaseComputeTime[i] * 1.0f) / (taskPeriods[i] * 1.0f);
	}

	if (alpha >= computeTimeSum)
		return true;
	return false;
}

/* Deadlines array has to be an array of pointers, to allow for the tasks to change the values inside the array
** during execution by changing the value of the pointer directly, intead of accessing the array
**
** To note: This function is not optimized for a huge amount of tasks, but having alarge amount of tasks 
** would break all the algorithms, therefore optimization here is not that important
*/
static int findNextDeadline(int **deadlinesArray, int numberOfTasks)
{
	int nextDeadline = *deadlinesArray[0]; // The element in the arrayis a pointer to the deadline of the First task
	for (int i = 1; i < numberOfTasks; i++)
	{
		if (nextDeadline > *deadlinesArray[i])
			nextDeadline = *deadlinesArray[i];
	}
	return nextDeadline;
}

/* Cycle Conserving DVS Implementation
   Only Implemented for RM
*/

#if numberOFTASKS != 3
#error Correct here to increase the number of Tasks, as this was a POC aimed at a system with 3 tasks
#endif

int c_left1, c_left2, c_left3;
int *c_lefti[3] = {&c_left1, &c_left2, &c_left3};

int d_1 = 0, d_2 = 0, d_3 = 0;
int *d_i[3] = {&d_1, &d_2, &d_3};

int frequencyChosenSVS = 96;

void setupCycleConservingDVS(
	int *taskPeriods, int *taskWorstCaseComputeTime)
{
	frequencyChosenSVS = staticVoltageScalingFrequencyLevelSelector(numberOFTASKS,
																	taskPeriods, taskWorstCaseComputeTime, 0);
	for (int i = 0; i < numberOFTASKS; i++)
	{
		*c_lefti[i] = taskWorstCaseComputeTime[i];
	}
}

int cycleConservingDVSFrequencySelector(int currentTick)
{
	// No need to convert into cycles, as the worst case computation time is in Ticks
	int maxTicksUntilNextDeadline = findNextDeadline(deadlines, numberOFTASKS);

	int totalD = 0;

	for (int i = 0; i < numberOFTASKS; i++)
	{
		totalD += *d_i[i];
	}

	float minimumFrequency = ((totalD * 1.0) / maxTicksUntilNextDeadline) * frequencyLevels[0];

	/* Can be optimized if we have a lot of frequencies to choose from, by only searching the bottom or top frequencies
	** Here it is not necessary as we have only 10 
	*/
	if (minimumFrequency > frequencyLevels[1])
		return 0; //If bigger than the 2 available frequency, we can only use the base

	int desiredFrequencyLevel = 0;
	for (int i = 1; i < availableFrequencyLevels; i++)
	{
		if (minimumFrequency > frequencyLevels[i])
			break;
		desiredFrequencyLevel++;
	}
	frequencyLevelSelector(desiredFrequencyLevel);
	return desiredFrequencyLevel;
}

void cycleConservingDVSAllocateCycles(int k)
{
	for (int i = 0; i < numberOFTASKS; i++)
	{
		if (*c_lefti[i] < k)
		{
			*d_i[i] = *c_lefti[i];
			k = k - *c_lefti[i];
		}
		else
		{
			*d_i[i] = k;
			k = 0;
		}
	}
}

void cycleConservingDVSTaskReady(int taskNumber, int currentTick)
{
	*c_lefti[taskNumber] = mainWorstCaseComputeTime[taskNumber];
	int s_m = findNextDeadline(deadlines, numberOFTASKS);
	int s_j = ceil(s_m * (frequencyChosenSVS * 1.0) / (frequencyLevels[0] * 1.0));
	cycleConservingDVSAllocateCycles(s_j);
	cycleConservingDVSFrequencySelector(currentTick);
}

void cycleConservingDVSTaskComplete(int taskNumber, int currentTick)
{
	*c_lefti[taskNumber] = 0;
	*d_i[taskNumber] = 0;
	cycleConservingDVSFrequencySelector(currentTick);
}

/* Cycle Conserving DVS EDF
*/

#if numberOFTASKS != 3
#error Correct here to increase the number of Tasks, as this was a POC aimed at a system with 3 tasks
#endif

float U_1 = 0, U_2 = 0, U_3 = 0;
float *U_i[3] = {&U_1, &U_2, &U_3};

int cycleConservingDVSFrequencySelectorEDF()
{

	float totalU = 0;

	for (int i = 0; i < numberOFTASKS; i++)
	{
		totalU += *U_i[i];
	}

	float minimumFrequency = totalU * frequencyLevels[0];

	/* Can be optimized if we have a lot of frequencies to choose from, by only searching the bottom or top frequencies
	** Here it is not necessary as we have only 10 
	*/
	if (minimumFrequency > frequencyLevels[1])
		return 0; //If bigger than the 2 available frequency, we can only use the base

	int desiredFrequencyLevel = 0;
	for (int i = 1; i < availableFrequencyLevels; i++)
	{
		if (minimumFrequency > frequencyLevels[i])
			break;
		desiredFrequencyLevel++;
	}
	frequencyLevelSelector(desiredFrequencyLevel);
	return desiredFrequencyLevel;
}

void cycleConservingDVSTaskReadyEDF(int taskNumber, int currentTick)
{
	int auxDeadline = *deadlines[taskNumber];
	*U_i[taskNumber] = mainWorstCaseComputeTime[taskNumber] * auxDeadline;
	cycleConservingDVSFrequencySelectorEDF(currentTick);
}

/* This one requires us to keep track of the execution time of the task. 
** Maybe should implement this for all the algorithms? 
** Or something available to all the the task
*/
void cycleConservingDVSTaskCompleteEDF(int taskNumber, int actualTaskExecutionTicks)
{
	int auxDeadline = *deadlines[taskNumber];
	*U_i[taskNumber] = actualTaskExecutionTicks / auxDeadline;
	cycleConservingDVSFrequencySelectorEDF();
}
