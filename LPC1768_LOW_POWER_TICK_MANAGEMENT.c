/*
 * FreeRTOS Kernel V10.3.1
 * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/* Standard includes. */
#include <limits.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"

/* User defined Variables */
#include <stdbool.h>
extern const int frequencyLevels[];
extern const int staticTickIncrement[];
extern const int periodicTickIncrement[];
extern volatile int currentFrequencyLevel;
extern volatile short periodicTickIncrementCount;
extern const short availableFrequencyLevels;
extern volatile bool frequencyChanged;

#define SBIT_TIMER1  2
#define SBIT_MR0I    0
#define SBIT_MR0R    1
#define SBIT_CNTEN   0
#define PCLK_TIMER1  4    

/* The frequency at which TIM2 will run. */
#define lpCLOCK_INPUT_FREQUENCY 	( 1000UL )

/* Calculate how many clock increments make up a single tick period. */
static const uint32_t ulReloadValueForOneTick = ( ( lpCLOCK_INPUT_FREQUENCY / configTICK_RATE_HZ ) - 1 );
unsigned int getPrescalarForUs(uint8_t timerPclkBit);

/*
 * When configDYNAMIC_FREQUENCY_LOW_POWER_MODE is set to 1 then the tick interrupt
 * is generated by the TIM2 peripheral.  The TIM2 configuration and handling
 * functions are defined in this file.  Note the RTC is not used as there does
 * not appear to be a way to read back the RTC count value, and therefore the
 * only way of knowing exactly how long a sleep lasted is to use the very low
 * resolution calendar time.
 *
 * When configDYNAMIC_FREQUENCY_LOW_POWER_MODE is set to 0 the tick interrupt is
 * generated by the standard FreeRTOS Cortex-M port layer, which uses the
 * SysTick timer.
 */
#if configDYNAMIC_FREQUENCY_LOW_POWER_MODE == 1

void dynamicFrequencySysTickHandler(void)
{
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();

	/* Increment the RTOS tick. */


	if (xTaskIncrementTick() != pdFALSE)
	{
		/* A context switch is required.  Context switching is performed in
		the PendSV interrupt.  Pend the PendSV interrupt. */
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
	}

	if(frequencyChanged) {
		periodicTickIncrementCount=0;
		frequencyChanged=false;
	}

	short extraTicks = staticTickIncrement[currentFrequencyLevel];
	if (periodicTickIncrementCount==periodicTickIncrement[currentFrequencyLevel]
		&& periodicTickIncrement[currentFrequencyLevel]!=0) {
		extraTicks++;
		periodicTickIncrementCount=0;
	}

	for (int i = 0; i < extraTicks; i++)
	{
		/* Increment the RTOS tick. */
		if (xTaskIncrementTick() != pdFALSE)
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
		}
	}

	periodicTickIncrementCount++;

	portENABLE_INTERRUPTS();
}
#endif //configDYNAMIC_FREQUENCY_LOW_POWER_MODE
void vPortSetupTimerInterrupt(void){

	LPC_SC->PCONP |= (1<<SBIT_TIMER1); /* Power ON Timer1 */


    LPC_TIM1->MCR  = (1<<SBIT_MR0I) | (1<<SBIT_MR0R);     /* Clear TC on MR0 match and Generate Interrupt*/
    LPC_TIM1->PR   = getPrescalarForUs(PCLK_TIMER1);      /* Prescalar for 1us */
    LPC_TIM1->MR0  = (1000/configTICK_RATE_HZ)*1000;                 /* Load timer value to generate 10ms delay*/
    LPC_TIM1->TCR  = (1 <<SBIT_CNTEN);                    /* Start timer by setting the Counter Enable*/
    NVIC_EnableIRQ(TIMER1_IRQn);                          /* Enable Timer1 Interrupt */
  
}

void TIMER1_IRQHandler(void) 
{
	LPC_TIM1->IR |= (1<<0); //Clear MR0 Interrupt flag
	#if configDYNAMIC_FREQUENCY_LOW_POWER_MODE == 1
	dynamicFrequencySysTickHandler();
	#else
	xPortSysTickHandler();
	#endif

}

/* Courtesy of https://www.exploreembedded.com/wiki/LPC1768:_Timers */
unsigned int getPrescalarForUs(uint8_t timerPclkBit)
{
    unsigned int pclk,prescalarForUs;
    pclk = (LPC_SC->PCLKSEL0 >> timerPclkBit) & 0x03; /* get the pclk info for required timer */

    switch ( pclk )                                   /* Decode the bits to determine the pclk*/
    {
    case 0x00:
        pclk = SystemCoreClock/4;
        break;

    case 0x01:
        pclk = SystemCoreClock;
        break; 

    case 0x02:
        pclk = SystemCoreClock/2;
        break; 

    case 0x03:
        pclk = SystemCoreClock/8;
        break;
    }

    prescalarForUs =pclk/1000000 - 1;                 /* Prescalar for 1us (1000000Counts/sec) */

    return prescalarForUs;
}
