/*
 * FreeRTOS Kernel V10.3.1
 * Copyright (C) 2020 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/* Standard includes. */
#include <limits.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "LPC1768_LOW_POWER_TICK_MANAGEMENT.h"
#include "math.h"
#include "ClockControl.h"

/* User defined Variables */
#include <stdbool.h>

//Global variables stablished during the setup
static int numberOfTasks = 0;
static int *taskWorstCaseComputeTime;
static int availableFrequencyLevels;
static int *frequencyStages;
static int *taskDeadlines;
static int mode;
static int currentFrequencyLevel;

// CCRTDVS Variables
static int *d_i;
static int *c_lefti;
static int frequencyChosenSVS = 0;

// Default values for frequency levels
const int default_frequencyStages[] = {24, 21, 18, 15, 12, 9, 6, 3};
const int default_availableFrequencyLevels = 8;

// volatile int currentFrequencyLevel = 0;
volatile short periodicTickIncrementCount = 0;
volatile bool frequencyChanged = false;
volatile bool cycleConservingUsed = false;

// extern int *deadlines[];
// extern int mainTaskPeriods[];
// extern int mainWorstCaseComputeTime[];

#define SBIT_TIMER1 2
#define SBIT_MR0I 0
#define SBIT_MR0R 1
#define SBIT_CNTEN 0
#define SBIT_CNRST 1
#define PCLK_TIMER1 4

/* The frequency at which TIM2 will run. */
#define lpCLOCK_INPUT_FREQUENCY (10000UL)

/* Calculate how many clock increments make up a single tick period. */
static const uint32_t ulReloadValueForOneTick = ((lpCLOCK_INPUT_FREQUENCY / configTICK_RATE_HZ) - 1);
unsigned int getPrescalarFor100Us(uint8_t timerPclkBit);

/* Flag set from the tick interrupt to allow the sleep processing to know if
sleep mode was exited because of an tick interrupt or a different interrupt. */
static volatile uint32_t ulTickFlag = pdFALSE;

/* Holds the maximum number of ticks that can be suppressed - which is
basically how far into the future an interrupt can be generated. Set during
initialisation. */
static TickType_t xMaximumPossibleSuppressedTicks = 0;

// /* For debugging*/
#ifndef FILE_H
#define FILE_H
#endif
#include "PowerControl.h"
#include "ClockControl.h"

#define LED1 18 //
#define LED2 20 //
#define LED3 21 //
#define LED4 23 //
#define frequencyLevelSelect(x) frequencyLevelSelector(x)
/* Write to GPIO 2 on Port 18,20,21,23
 Initialized on main  otherwise initialize here
 Can't use mbed.h cause its not a .cpp file, and a .cpp file complains about the normal port tick 
 interrupt
LED1 = P1_18,
LED2 = P1_20,
LED3 = P1_21,
LED4 = P1_23,
*/

// #ifdef DEBUG

#define configPRE_SLEEP_PROCESSING(x) \
	LPC_GPIO1->FIOPIN = (1 << LED1);  \
	Sleep();
#define configPOST_SLEEP_PROCESSING(x) LPC_GPIO1->FIOPIN = (0 << LED1);

// #else
// #define configPRE_SLEEP_PROCESSING(x) Sleep();
// #define configPOST_SLEEP_PROCESSING(x) LPC_GPIO1->FIOPIN = (0 << LED1);

// #endif

int frequencyLevelSelector(int level)
{
	if(level == currentFrequencyLevel) return currentFrequencyLevel;
	if (level < 0 || level > availableFrequencyLevels)
	{
		return currentFrequencyLevel;
	}

	
	taskENTER_CRITICAL();
	currentFrequencyLevel = level;
	setSystemFrequency(3, 0, mValues[level], 1);
	updatePrescalerTIMER1();
	frequencyChanged = true;
	taskEXIT_CRITICAL();
	// portENABLE_INTERRUPTS();
	return level;
}

/*
 * When configDYNAMIC_FREQUENCY_LOW_POWER_MODE is set to 1 then the tick interrupt
 * is generated by the TIM2 peripheral.  The TIM2 configuration and handling
 * functions are defined in this file.  Note the RTC is not used as there does
 * not appear to be a way to read back the RTC count value, and therefore the
 * only way of knowing exactly how long a sleep lasted is to use the very low
 * resolution calendar time.
 *
 * When configDYNAMIC_FREQUENCY_LOW_POWER_MODE is set to 0 the tick interrupt is
 * generated by the standard FreeRTOS Cortex-M port layer, which uses the
 * SysTick timer.
 */

#if configDYNAMIC_FREQUENCY_LOW_POWER_MODE == 1

void dynamicFrequencySysTickHandler(void)
{
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();

	/* Increment the RTOS tick. */

	if (xTaskIncrementTick() != pdFALSE)
	{
		/* A context switch is required.  Context switching is performed in
		the PendSV interrupt.  Pend the PendSV interrupt. */
		portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
	}

	if (frequencyChanged)
	{
		
		frequencyChanged = false;
	}


	portENABLE_INTERRUPTS();

	/* The CPU woke because of a tick. */
	ulTickFlag = pdTRUE;
}

void vPortSetupTimerInterrupt(void)
{

	LPC_SC->PCONP |= (1 << SBIT_TIMER1); /* Power ON Timer1 */

	LPC_TIM1->MCR = (1 << SBIT_MR0I) | (1 << SBIT_MR0R); /* Clear TC on MR0 match and Generate Interrupt*/
	LPC_TIM1->PR = getPrescalarFor100Us(PCLK_TIMER1);	 /* Prescalar for 100us */
	LPC_TIM1->MR0 = (1000 / configTICK_RATE_HZ) * 10;	 /* Load timer value to generate Tick Rate delay*/
	LPC_TIM1->TCR = (1 << SBIT_CNTEN);					 /* Start timer by setting the Counter Enable*/
	NVIC_EnableIRQ(TIMER1_IRQn);

	/* See the comments where xMaximumPossibleSuppressedTicks is declared. */
	xMaximumPossibleSuppressedTicks = ((unsigned long)USHRT_MAX) / ulReloadValueForOneTick;
}

void disableTIMER1(void)
{

	LPC_TIM1->TCR = (0 << SBIT_CNTEN); /* Start timer by setting the Counter Enable*/
	NVIC_DisableIRQ(TIMER1_IRQn);	   /* Enable Timer1 Interrupt */
}

void enableTIMER1(void)
{

	LPC_TIM1->TCR = (1 << SBIT_CNTEN); /* Stop timer by setting the Counter Enable to 0*/
	NVIC_EnableIRQ(TIMER1_IRQn);	   /* Disable Timer1 Interrupt */
}

void resetTIMER1(void)
{

	LPC_TIM1->TCR = (1 << SBIT_CNRST); /* Reset the timer by setting the Counter Reset*/
	LPC_TIM1->TCR = (0 << SBIT_CNRST); /* Reset the timer by setting the Counter Reset*/
}

void setReloadValueTIMER1(int reloadValue)
{
	LPC_TIM1->MR0 = reloadValue;
}

void setCounterTIMER1(uint32_t counterValue)
{
	LPC_TIM1->TC = counterValue;
}

uint32_t getCounterTIMER1(void)
{
	return LPC_TIM1->TC;
}

void updatePrescalerTIMER1(void)
{
	LPC_TIM1->PR = getPrescalarFor100Us(PCLK_TIMER1);
}
void TIMER1_IRQHandler(void)
{
	LPC_TIM1->IR |= (1 << 0); //Clear MR0 Interrupt flag
	dynamicFrequencySysTickHandler();
}

/* Courtesy of https://www.exploreembedded.com/wiki/LPC1768:_Timers */
unsigned int getPrescalarFor100Us(uint8_t timerPclkBit)
{
	unsigned int pclk, prescalarFor100Us;
	pclk = (LPC_SC->PCLKSEL0 >> timerPclkBit) & 0x03; /* get the pclk info for required timer */

	switch (pclk) /* Decode the bits to determine the pclk*/
	{
	case 0x00:
		pclk = SystemCoreClock / 4;
		break;

	case 0x01:
		pclk = SystemCoreClock;
		break;

	case 0x02:
		pclk = SystemCoreClock / 2;
		break;

	case 0x03:
		pclk = SystemCoreClock / 8;
		break;
	}

	prescalarFor100Us = pclk / 10000 - 1; /* Prescalar for 1us (1000000Counts/sec) */
	//prescalarForMs = pclk / 1000 - 1; /* Prescalar for 1us (1000000Counts/sec) */
	//prescalarForUs = pclk / 1000000 - 1; /* Prescalar for 1us (1000000Counts/sec) */

	return prescalarFor100Us;
}

void vApplicationSleep(TickType_t xExpectedIdleTime)
{
	uint32_t ulCounterValue, ulReloadValue, ulCompleteTickPeriods;
	TickType_t xModifiableIdleTime;

	/* Make sure the SysTick reload value does not overflow the counter. */
	if (xExpectedIdleTime > xMaximumPossibleSuppressedTicks)
	{
		xExpectedIdleTime = xMaximumPossibleSuppressedTicks;
	}

	/* Stop the Tick Timer momentarily.  The time the Tick Timer is stopped for
	is accounted for as best it can be, but using the tickless mode will
	inevitably result in some tiny drift of the time maintained by the
	kernel with respect to calendar time. */
	disableTIMER1();

	/* Calculate the reload value required to wait xExpectedIdleTime
	tick periods.  -1 is used because this code will execute part way
	through one of the tick periods. */
	ulReloadValue = ulReloadValueForOneTick * xExpectedIdleTime;

	// if (ulReloadValue > ulStoppedTimerCompensation)
	// {
	// 	ulReloadValue -= ulStoppedTimerCompensation;
	// }

	/* Enter a critical section but don't use the taskENTER_CRITICAL()
	method as that will mask interrupts that should exit sleep mode. */
	__asm volatile("cpsid i" ::
					   : "memory");
	__asm volatile("dsb");
	__asm volatile("isb");

	/* The tick flag is set to false before sleeping.  If it is true when sleep
	mode is exited then sleep mode was probably exited because the tick was
	suppressed for the entire xExpectedIdleTime period. */
	ulTickFlag = pdFALSE;

	/* If a context switch is pending or a task is waiting for the scheduler
	to be unsuspended then abandon the low power entry. */
	if (eTaskConfirmSleepModeStatus() == eAbortSleep)
	{
		/* Restart from whatever is left in the count register to complete
		this tick period. */
		enableTIMER1();

		/* Re-enable interrupts - see comments above the cpsid instruction()
		above. */
		__asm volatile("cpsie i" ::
						   : "memory");
	}
	else
	{
		/* Adjust the TIM2 value to take into account that the current time
		slice is already partially complete. */
		ulReloadValue -= (uint32_t)getCounterTIMER1();
		/* Set the new reload value. */

		//portNVIC_SYSTICK_LOAD_REG = ulReloadValue;
		setReloadValueTIMER1(ulReloadValue);

		/* Clear the SysTick count flag and set the count value back to
		zero. */
		resetTIMER1();
		setCounterTIMER1(0);

		/* Restart SysTick. */
		enableTIMER1();

		/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
		set its parameter to 0 to indicate that its implementation contains
		its own wait for interrupt or wait for event instruction, and so wfi
		should not be executed again.  However, the original expected idle
		time variable must remain unmodified, so a copy is taken. */
		xModifiableIdleTime = xExpectedIdleTime;
		configPRE_SLEEP_PROCESSING(xModifiableIdleTime);
		if (xModifiableIdleTime > 0)
		{
			__asm volatile("dsb" ::
							   : "memory");
			__asm volatile("wfi");
			__asm volatile("isb");
		}
		configPOST_SLEEP_PROCESSING(xExpectedIdleTime);

		/* Re-enable interrupts to allow the interrupt that brought the MCU
		out of sleep mode to execute immediately.  see comments above
		__disable_interrupt() call above. */
		__asm volatile("cpsie i" ::
						   : "memory");
		__asm volatile("dsb");
		__asm volatile("isb");

		/* Disable interrupts again because the clock is about to be stopped
		and interrupts that execute while the clock is stopped will increase
		any slippage between the time maintained by the RTOS and calendar
		time. */
		__asm volatile("cpsid i" ::
						   : "memory");
		__asm volatile("dsb");
		__asm volatile("isb");

		/* Disable the SysTick clock without reading the
		portNVIC_SYSTICK_CTRL_REG register to ensure the
		portNVIC_SYSTICK_COUNT_FLAG_BIT is not cleared if it is set.  Again,
		the time the SysTick is stopped for is accounted for as best it can
		be, but using the tickless mode will inevitably result in some tiny
		drift of the time maintained by the kernel with respect to calendar
		time*/
		disableTIMER1();

		/* Determine if the SysTick clock has already counted to zero and
		been set back to the current reload value (the reload back being
		correct for the entire expected idle time) or if the SysTick is yet
		to count to zero (in which case an interrupt other than the SysTick
		must have brought the system out of sleep mode). */
		if (ulTickFlag != pdFALSE)
		{
			/* The tick interrupt is already pending, and the SysTick count
			reloaded with ulReloadValue.  Reset the
			portNVIC_SYSTICK_LOAD_REG with whatever remains of this tick
			period. */
			ulCounterValue = ulReloadValueForOneTick - getCounterTIMER1();

			/* Trap under/overflows before the calculated value is used. */
			configASSERT(ulCounterValue >= 0);

			setReloadValueTIMER1(ulCounterValue);
			setCounterTIMER1(0);

			/* As the pending tick will be processed as soon as this
			function exits, the tick value maintained by the tick is stepped
			forward by one less than the time spent waiting. */
			ulCompleteTickPeriods = xExpectedIdleTime - 1UL;
		}
		else
		{
			/* Something other than the tick interrupt ended the sleep.
			Work out how long the sleep lasted rounded to complete tick
			periods (not the ulReload value which accounted for part
			ticks). */
			ulCompleteTickPeriods = (getCounterTIMER1()) / ulReloadValueForOneTick;

			/* The reload value is set to whatever fraction of a single tick
			period remains. */
			ulCounterValue = (getCounterTIMER1()) - (ulCompleteTickPeriods * ulReloadValueForOneTick);

			if (ulCounterValue == 0)
			{
				/* There is no fraction remaining. */
				ulCounterValue = ulReloadValueForOneTick;
				ulCompleteTickPeriods++;
			}

			setReloadValueTIMER1(ulCounterValue);
			setCounterTIMER1(0);
		}

		/* Restart SysTick so it runs from portNVIC_SYSTICK_LOAD_REG
		again, then set portNVIC_SYSTICK_LOAD_REG back to its standard
		value. */
		setCounterTIMER1(0);
		enableTIMER1();
		vTaskStepTick(ulCompleteTickPeriods);
		setReloadValueTIMER1(ulReloadValueForOneTick);

		/* Exit with interrupts enabled. */
		__asm volatile("cpsie i" ::
						   : "memory");
	}
}

#endif

#ifdef __cplusplus
extern "C"
#endif

	// DVFS Functions
	void
	setupDVFS(int main_numberOfTasks, int *main_taskWorstCaseComputeTime, int *main_taskDeadlines, int main_availableFrequencyLevels, int *main_frequencyStages, int main_mode)
{

	numberOfTasks = main_numberOfTasks;
	taskWorstCaseComputeTime = main_taskWorstCaseComputeTime;
	taskDeadlines = main_taskDeadlines;
	mode = main_mode;
	availableFrequencyLevels = main_availableFrequencyLevels;
	frequencyStages = main_frequencyStages;
}

#ifdef __cplusplus
extern "C"
#endif
	void
	default_setupDVFS(int main_numberOfTasks, int *main_taskWorstCaseComputeTime, int *main_taskDeadlines, int main_mode)
{
	numberOfTasks = main_numberOfTasks;
	taskWorstCaseComputeTime = main_taskWorstCaseComputeTime;
	taskDeadlines = main_taskDeadlines;
	mode = main_mode;
	availableFrequencyLevels = default_availableFrequencyLevels;
	frequencyStages = default_frequencyStages;
}

#ifdef __cplusplus
extern "C"
#endif
	int
	staticVoltageScalingFrequencyLevelSelector()
{

	float alphaToTest = 0.0f;
	bool validAlpha = true;
	int i = 0;
	int selectedFrequencyLevel = 0;

	//Catch error if setup not implemented
	if (numberOfTasks == 0)
	{
		return -2;
	}

	/* Even if it fails in the max frequency, will return 0 and operate at max frequency
		If it is valid through all levels the second condition will act and stop the loop*/
	// if (mode == 0) //RM
	// {
	while (validAlpha && i < availableFrequencyLevels)
	{
		alphaToTest = (frequencyStages[i] * 1.0f) / (frequencyStages[0] * 1.0f);
		validAlpha = staticVoltageScalingRM_Test(alphaToTest);
		if (validAlpha)
			i++;
	}
	if (!validAlpha && i == 0)
		return -1;
	selectedFrequencyLevel = i - 1;
	
	return frequencyLevelSelect(selectedFrequencyLevel);
	// return currentFrequencyLevel;
	// }

	// if (mode == 1) //EDF
	// {
	// 	while (validAlpha && i < availableFrequencyLevels)
	// 	{
	// 		alphaToTest = (frequencyStages[i] * 1.0f) / (frequencyStages[0] * 1.0f);
	// 		validAlpha = staticVoltageScalingEDF_Test(alphaToTest);
	// 		if (validAlpha)
	// 			i++;
	// 	}
	// 	if(!validAlpha && i==0) return -1;
	// 	selectedFrequencyLevel = i - 1;
	// 	currentFrequencyLevel = selectedFrequencyLevel;
	// 	return frequencyLevelSelector(selectedFrequencyLevel);
	// }
}

bool staticVoltageScalingRM_Test(float alpha)
{

	int currentTaskInTest = 0;
	float computeTimeSum = 0;
	float ceilAux = 0;
	int i = 0;

	while (1)
	{
		for (i = 0; i < currentTaskInTest + 1; i++)
		{
			ceilAux = (taskDeadlines[currentTaskInTest] / 1.0f) / (taskDeadlines[i] / 1.0f);
			if (ceilAux != (int)ceilAux)
				ceilAux = (int)ceilAux + 1;							 //If true, there is floating point, hence we remove and add one to ceil the value
			computeTimeSum += ceilAux * taskWorstCaseComputeTime[i]; //ceil
		}

		if (alpha * taskDeadlines[currentTaskInTest] >= computeTimeSum)
		{

			if (currentTaskInTest + 1 == numberOfTasks)
				return true; //Alpha is valid and deadlines are not violated

			/* Reset the sum and test the next Task*/
			computeTimeSum = 0;
			currentTaskInTest++;
		}
		else
			return false;
	}
}

/* Deadlines array has to be an array of pointers, to allow for the tasks to change the values inside the array
** during execution by changing the value of the pointer directly, intead of accessing the array
**
** To note: This function is not optimized for a huge amount of tasks, but having alarge amount of tasks 
** would break all the algorithms, therefore optimization here is not that important
*/
static int findNextDeadline(int *deadlinesArray, int currentTick)
{
	int nextDeadline = INT32_MAX; // The element in the array is a pointer to the deadline of the First task
	int i = 0;
	for (i = 0; i < numberOfTasks; i++)
	{
		if (nextDeadline > deadlinesArray[i] && deadlinesArray[i] > currentTick)
			nextDeadline = deadlinesArray[i];
	}
	return nextDeadline;
}

/* Cycle Conserving DVS Implementation
   Only Implemented for RM
*/
// Changed the numberOfTasks to a local variable
int setupCycleConservingDVS()
{
	
	mode = 0;
	frequencyChosenSVS = staticVoltageScalingFrequencyLevelSelector();
	if (frequencyChosenSVS == -1)
		return -1;
	int i = 0;

	d_i = (int *)pvPortMalloc(numberOfTasks * sizeof(int));
	c_lefti = (int *)pvPortMalloc(numberOfTasks * sizeof(int));
	

	if (frequencyChosenSVS < 0)
		return-1;
	for (i = 0; i < numberOfTasks; i++)
	{
		c_lefti[i] = taskWorstCaseComputeTime[i];
	}
	cycleConservingUsed = true;
	return frequencyChosenSVS;
}

//Changed number of Tasks to local
// Changed deadlines to local
int cycleConservingDVSFrequencySelector(int currentTick)
{
	// No need to convert into cycles, as the worst case computation time is in Ticks
	int maxTicksUntilNextDeadline = findNextDeadline(taskDeadlines, currentTick) - currentTick;

	int totalD = 0;

	int desiredFrequencyLevel = 0;

	int i = 0;

	for (i = 0; i < numberOfTasks; i++)
	{
		totalD += d_i[i];
	}

	float minimumFrequency = ((totalD * 1.0) / maxTicksUntilNextDeadline) * frequencyStages[0];

	/* Can be optimized if we have a lot of frequencies to choose from, by only searching the bottom or top frequencies
	** Here it is not necessary as we have only 10 
	*/
	if (minimumFrequency > frequencyStages[1])
	{
		desiredFrequencyLevel = 0; //If bigger than the 2 available frequency, we can only use the base
	
	}
	else
	{
		for (i = 1; i < availableFrequencyLevels; i++)
		{
			if (minimumFrequency > frequencyStages[i])
				break;
			desiredFrequencyLevel++;
		}
	}
	// Esta a causar erros aqui for some reason (devia ser assim o codigo antigo quando calculava
	// para ir pra o nivel maximo nao ia, fazendo com que deadlines fossem missed)
	frequencyLevelSelector(desiredFrequencyLevel);
	return desiredFrequencyLevel;
}

void cycleConservingDVSAllocateCycles(int k)
{
	int i = 0;
	for (i = 0; i < numberOfTasks; i++)
	{
		if (c_lefti[i] < k)
		{
			d_i[i] = c_lefti[i];
			k = k - c_lefti[i];
		}
		else
		{
			d_i[i] = k;
			k = 0;
		}
	}
}

int cycleConservingDVSTaskReady(int taskNumber, int currentTick, int taskNextExecution)
{
	taskDeadlines[taskNumber] = taskNextExecution;
	c_lefti[taskNumber] = taskWorstCaseComputeTime[taskNumber];
	int s_m = findNextDeadline(taskDeadlines, currentTick) - currentTick;

	float ceilAux = (s_m * (frequencyStages[frequencyChosenSVS] * 1.0) / (frequencyStages[0] * 1.0));
	if (ceilAux != (int)ceilAux)
		ceilAux = (int)ceilAux + 1; //If true, there is floating point, hence we remove and add one to ceil the value

	int s_j = ceilAux;

	//int s_j = ceil(s_m * (frequencyStages[currentFrequencyLevel] * 1.0) / (frequencyStages[0] * 1.0));
	cycleConservingDVSAllocateCycles(s_j);

	return cycleConservingDVSFrequencySelector(currentTick);
}

int cycleConservingDVSTaskComplete(int taskNumber, int currentTick)
{
	c_lefti[taskNumber] = 0;
	d_i[taskNumber] = 0;

	return cycleConservingDVSFrequencySelector(currentTick);
}

bool sufficientSchedulabilityTest(int main_numberOfTasks, int *taskWorstCaseComputeTime, int *taskDeadlines)
{
	float utilization = 0, utilizationBound = 0;
	int i = 0;

	utilizationBound = numberOfTasks * (pow(2, (1.0 / numberOfTasks)) - 1);

	for (i = 0; i < numberOfTasks; i++)
	{
		utilization += taskWorstCaseComputeTime[i] / taskDeadlines[i];
	}

	if (utilization > 1.0 || utilization > utilizationBound)
		return false;
	return true;
}
/*
int setupPowerSaving(int main_numberOfTasks, int *main_taskWorstCaseComputeTime, int *main_taskDeadlines, int main_availableFrequencyLevels, int *main_frequencyStages, int main_mode)
{

	setupDVFS(main_numberOfTasks, main_taskWorstCaseComputeTime, main_taskDeadlines, main_availableFrequencyLevels, main_frequencyStages, main_mode);

	switch (mode)
	{
	//Sleep on idle
	case 0:
#define configUSE_TICKLESS_IDLE 0
#define config_SLEEP_ON_IDLE 1
		break;
	//Sleep on Tickless
	case 1:
#define configUSE_TICKLESS_IDLE 2
#define config_SLEEP_ON_IDLE 0
		break;

		//if (!sufficientSchedulabilityTest())
		return -1;
	//SVS no tickless
	case 2:
#define configUSE_TICKLESS_IDLE 0
		if (!staticVoltageScalingFrequencyLevelSelector())
			return -3;
		break;
	//SVS Tickless
	case 3:
#define configUSE_TICKLESS_IDLE 2
		if (!staticVoltageScalingFrequencyLevelSelector())
			return -3;
		break;
	//Cycle Conserving no Tickless
	case 4:
#define configUSE_TICKLESS_IDLE 0
		if (!setupCycleConservingDVS())
			return -2;
		break;
	//Cycle conserving Tickless
	case 5:
#define configUSE_TICKLESS_IDLE 2
		if (!setupCycleConservingDVS())
			return -2;
		break;
	}
	return 0;
	//implement feasibility test
}
*/
void vTaskStartLowPowerScheduller(int main_numberOfTasks, int *main_taskWorstCaseComputeTime, int *main_taskDeadlines, int main_availableFrequencyLevels, int *main_frequencyStages, int main_mode)
{
	int selectedLevel = 0;
	if (!sufficientSchedulabilityTest(main_numberOfTasks, main_taskWorstCaseComputeTime, main_taskDeadlines))
	{

		LPC_GPIO1->FIOPIN = (1 << 18);
		LPC_GPIO1->FIOPIN = (1 << 20);
		LPC_GPIO1->FIOPIN = (1 << 21);
		LPC_GPIO1->FIOPIN = (1 << 23);

		return;
	}

	switch (main_mode)
	{
	//Sleep on idle
	case 0:
		break;
	//SVS
	case 1:
		setupDVFS(main_numberOfTasks, main_taskWorstCaseComputeTime, main_taskDeadlines, main_availableFrequencyLevels, main_frequencyStages, main_mode);
		selectedLevel = staticVoltageScalingFrequencyLevelSelector();
		//if(selectedLevel>2) LPC_GPIO1->FIOPIN = (1 << 23);
		break;
	//Cycle Conserving no Tickless
	case 2:
		setupDVFS(main_numberOfTasks, main_taskWorstCaseComputeTime, main_taskDeadlines, main_availableFrequencyLevels, main_frequencyStages, main_mode);
		setupCycleConservingDVS();
		break;
	}
	//wait(5);
	
}
